;;;omg

# Bytecode compiler constants mirrored from Python implementation.

# Import interpreter utilities for tokenizing and parsing without
# executing its command-line entry point on import.
alloc _saved_args := args
args := []
import "./interpreter.omg" as OMGInterpreter
args := _saved_args

# Bytecode header and version constants.
alloc MAGIC_HEADER := [79, 77, 71, 66]
alloc BC_VERSION := 257  # 0x00000101 (major=0, minor=1, patch=1)

alloc OPCODES := {
    PUSH_INT: 0,
    PUSH_STR: 1,
    PUSH_BOOL: 2,
    BUILD_LIST: 3,
    BUILD_DICT: 4,
    LOAD: 5,
    STORE: 6,
    ADD: 7,
    SUB: 8,
    MUL: 9,
    DIV: 10,
    MOD: 11,
    EQ: 12,
    NE: 13,
    LT: 14,
    LE: 15,
    GT: 16,
    GE: 17,
    BAND: 18,
    BOR: 19,
    BXOR: 20,
    SHL: 21,
    SHR: 22,
    AND: 23,
    OR: 24,
    NOT: 25,
    NEG: 26,
    INDEX: 27,
    SLICE: 28,
    JUMP: 29,
    JUMP_IF_FALSE: 30,
    CALL: 31,
    TCALL: 32,
    BUILTIN: 33,
    POP: 34,
    PUSH_NONE: 35,
    RET: 36,
    EMIT: 37,
    HALT: 38,
    STORE_INDEX: 39,
    ATTR: 40,
    STORE_ATTR: 41,
    ASSERT: 42,
    CALL_VALUE: 43,
    SETUP_EXCEPT: 44,
    POP_BLOCK: 45,
    RAISE: 46
}


alloc ERROR_KIND_TO_CODE := {
    Generic: 0,
    Syntax: 1,
    Type: 2,
    UndefinedIdent: 3,
    Value: 4,
    ModuleImport: 5
}


# Return opcode value for the given mnemonic.
proc opcode(name) {
    return OPCODES[name]
}

# Current instruction stream as a list of [op, arg] pairs.
alloc code := []

# Pending function bodies waiting to be appended.
alloc pending_funcs := []

# Finalized function metadata entries.
alloc funcs := []

# Stack of lists used to patch `break` statements.
alloc break_stack := []

# Names of builtin functions recognized by the compiler.

# ------------------------------------------------------------------
# Byte manipulation helpers
# ------------------------------------------------------------------

# Pack a 32-bit unsigned integer into little-endian byte list.
proc pack_u32(n) {
    return [n & 255, (n >> 8) & 255, (n >> 16) & 255, (n >> 24) & 255]
}

# Pack a 64-bit signed integer into little-endian byte list.
proc pack_i64(n) {
    if n < 0 {
        n := (1 << 64) + n
    }
    alloc res := []
    alloc i := 0
    loop i < 8 {
        res := res + [n & 255]
        n := n >> 8
        i := i + 1
    }
    return res
}

# Convert a UTF-8 string into a list of byte values.
proc str_bytes(s) {
    alloc out := []
    alloc i := 0
    alloc n := length(s)
    loop i < n {
        out := out + [ascii(s[i])]
        i := i + 1
    }
    return out
}

# Encode the current bytecode into a list of bytes matching the Python serializer.
proc encode_bytecode(final_code) {
    alloc out := MAGIC_HEADER
    out := out + pack_u32(BC_VERSION)
    out := out + pack_u32(length(funcs))
    alloc i := 0
    loop i < length(funcs) {
        alloc f := funcs[i]
        alloc name_bytes := str_bytes(f.name)
        out := out + pack_u32(length(name_bytes))
        out := out + name_bytes
        out := out + pack_u32(length(f.params))
        alloc j := 0
        loop j < length(f.params) {
            alloc pb := str_bytes(f.params[j])
            out := out + pack_u32(length(pb))
            out := out + pb
            j := j + 1
        }
        out := out + pack_u32(f.address)
        i := i + 1
    }
    out := out + pack_u32(length(final_code))
    i := 0
    loop i < length(final_code) {
        alloc instr := final_code[i]
        alloc op := instr[0]
        alloc arg := instr[1]
        out := out + [op]
        if op == opcode("PUSH_INT") {
            out := out + pack_i64(arg)
        } elif op == opcode("PUSH_STR") {
            alloc sb := str_bytes(arg)
            out := out + pack_u32(length(sb))
            out := out + sb
        } elif op == opcode("PUSH_BOOL") {
            if arg {
                out := out + [1]
            } else {
                out := out + [0]
            }
        } elif op == opcode("BUILD_LIST") or op == opcode("BUILD_DICT") or op == opcode("CALL_VALUE") {
            out := out + pack_u32(arg)
        } elif op == opcode("LOAD") or op == opcode("STORE") or op == opcode("CALL") or op == opcode("TCALL") or op == opcode("ATTR") or op == opcode("STORE_ATTR") {
            alloc sb2 := str_bytes(arg)
            out := out + pack_u32(length(sb2))
            out := out + sb2
        } elif op == opcode("BUILTIN") {
            alloc name := arg[0]
            alloc argc := arg[1]
            alloc sb3 := str_bytes(name)
            out := out + pack_u32(length(sb3))
            out := out + sb3
            out := out + pack_u32(argc)
        } elif op == opcode("RAISE") {
            out := out + [ERROR_KIND_TO_CODE[arg]]
        } elif op == opcode("JUMP") or op == opcode("JUMP_IF_FALSE") or op == opcode("SETUP_EXCEPT") {
            out := out + pack_u32(arg)
        }
        i := i + 1
    }
    return out
}

# Create a FunctionEntry record.
proc make_function_entry(name, params, address) {
    return { name: name, params: params, address: address }
}

# Emit a bytecode instruction.
proc emit_instr(op, arg) {
    code := code + [[op, arg]]
}

# Emit a placeholder instruction and return its index for later patching.
proc emit_placeholder(op) {
    alloc idx := length(code)
    code := code + [[op, false]]
    return idx
}

# Patch a previously emitted placeholder with the given target.
proc patch(idx, target) {
    alloc entry := code[idx]
    code[idx] := [entry[0], target]
}

# Check if a function name corresponds to a built-in.
proc is_builtin(name) {
    if name == "chr" or name == "ascii" or name == "hex" or name == "binary" {
        return true
    } elif name == "length" or name == "read_file" or name == "write_file" or name == "freeze" or name == "call_builtin" {
        return true
    } elif name == "file_open" or name == "file_read" or name == "file_write" or name == "file_close" or name == "file_exists" {
        return true
    }
    return false
}

# Compile a block of statements.
proc compile_block(block) {
    alloc i := 0
    alloc n := length(block)
    loop i < n {
        compile_stmt(block[i])
        i := i + 1
    }
}

# Compile a single statement node.
proc compile_stmt(stmt) {
    alloc kind := stmt[0]
    if kind == "emit" {
        compile_expr(stmt[1])
        emit_instr(opcode("EMIT"), false)
    } elif kind == "decl" or kind == "assign" {
        alloc name := stmt[1]
        alloc expr := stmt[2]
        compile_expr(expr)
        emit_instr(opcode("STORE"), name)
    } elif kind == "attr_assign" {
        alloc base := stmt[1]
        alloc attr := stmt[2]
        alloc expr := stmt[3]
        compile_expr(base)
        compile_expr(expr)
        emit_instr(opcode("STORE_ATTR"), attr)
    } elif kind == "index_assign" {
        alloc base := stmt[1]
        alloc index_expr := stmt[2]
        alloc value_expr := stmt[3]
        compile_expr(base)
        compile_expr(index_expr)
        compile_expr(value_expr)
        emit_instr(opcode("STORE_INDEX"), false)
    } elif kind == "expr_stmt" {
        compile_expr(stmt[1])
        emit_instr(opcode("POP"), false)
    } elif kind == "import" {
        raise("RuntimeError: Module imports are resolved by the interpreter and cannot be compiled")
    } elif kind == "facts" {
        compile_expr(stmt[1])
        emit_instr(opcode("ASSERT"), false)
    } elif kind == "if" {
        alloc cond_blocks := []
        alloc else_block := false
        alloc current := stmt
        loop true {
            alloc cond := current[1]
            alloc block_node := current[2]
            alloc block_stmts := []
            if block_node[0] == "block" {
                block_stmts := block_node[1]
            }
            cond_blocks := cond_blocks + [[cond, block_stmts]]
            alloc tail := current[3]
            if tail != false and tail[0] == "if" {
                current := tail
            } else {
                if tail != false {
                    if tail[0] == "block" {
                        else_block := tail[1]
                    }
                }
                break
            }
        }
        alloc end_jumps := []
        alloc i := 0
        alloc cb_len := length(cond_blocks)
        loop i < cb_len {
            alloc pair := cond_blocks[i]
            alloc cond := pair[0]
            alloc block := pair[1]
            compile_expr(cond)
            alloc jf := emit_placeholder(opcode("JUMP_IF_FALSE"))
            compile_block(block)
            end_jumps := end_jumps + [emit_placeholder(opcode("JUMP"))]
            patch(jf, length(code))
            i := i + 1
        }
        if else_block != false {
            compile_block(else_block)
        }
        alloc j := 0
        alloc ej_len := length(end_jumps)
        loop j < ej_len {
            patch(end_jumps[j], length(code))
            j := j + 1
        }
    } elif kind == "loop" {
        alloc cond := stmt[1]
        alloc body_node := stmt[2]
        alloc body := []
        if body_node[0] == "block" {
            body := body_node[1]
        }
        alloc start := length(code)
        compile_expr(cond)
        alloc jf := emit_placeholder(opcode("JUMP_IF_FALSE"))
        break_stack := break_stack + [[]]
        compile_block(body)
        emit_instr(opcode("JUMP"), start)
        patch(jf, length(code))
        alloc bs_len := length(break_stack)
        alloc breaks := break_stack[bs_len - 1]
        break_stack := break_stack[0:bs_len - 1]
        alloc k := 0
        alloc b_len := length(breaks)
        loop k < b_len {
            patch(breaks[k], length(code))
            k := k + 1
        }
    } elif kind == "try" {
        alloc try_block := stmt[1]
        alloc exc_name := stmt[2]
        alloc except_block := stmt[3]
        alloc handler_idx := emit_placeholder(opcode("SETUP_EXCEPT"))
        alloc try_body := []
        if try_block[0] == "block" {
            try_body := try_block[1]
        }
        compile_block(try_body)
        emit_instr(opcode("POP_BLOCK"), false)
        alloc end_jump := emit_placeholder(opcode("JUMP"))
        patch(handler_idx, length(code))
        if exc_name != false {
            emit_instr(opcode("STORE"), exc_name)
        }
        alloc except_body := []
        if except_block[0] == "block" {
            except_body := except_block[1]
        }
        compile_block(except_body)
        patch(end_jump, length(code))
    } elif kind == "func_def" {
        alloc name := stmt[1]
        alloc params := stmt[2]
        alloc body_node := stmt[3]
        alloc body := []
        if body_node[0] == "block" {
            body := body_node[1]
        }
        alloc body_code := _compile_function_body(body)
        pending_funcs := pending_funcs + [[name, params, body_code]]
    } elif kind == "return" {
        alloc expr := stmt[1]
        if expr[0] == "func_call" and expr[1][0] == "ident" {
            alloc func_node := expr[1]
            alloc args := expr[2]
            alloc name := func_node[1]
            alloc i := 0
            alloc n := length(args)
            loop i < n {
                compile_expr(args[i])
                i := i + 1
            }
            if is_builtin(name) {
                emit_instr(opcode("BUILTIN"), [name, n])
                emit_instr(opcode("RET"), false)
            } else {
                emit_instr(opcode("TCALL"), name)
            }
        } else {
            compile_expr(expr)
            emit_instr(opcode("RET"), false)
        }
    } elif kind == "break" {
        if length(break_stack) == 0 {
            raise("SyntaxError: 'break' used outside of loop")
        }
        alloc j := emit_placeholder(opcode("JUMP"))
        alloc bs_len := length(break_stack)
        alloc top := break_stack[bs_len - 1]
        top := top + [j]
        break_stack[bs_len - 1] := top
    } elif kind == "block" {
        compile_block(stmt[1])
    } else {
        raise("RuntimeError: Unsupported statement: " + kind)
    }
}

# Compile the body of a function into bytecode.
proc _compile_function_body(body) {
    alloc saved_code := code
    code := []
    compile_block(body)
    emit_instr(opcode("RET"), false)
    alloc func_code := code + []
    code := saved_code
    return func_code
}

# Compile special raise helper calls into RAISE instructions.
proc compile_raise_call(name, args) {
    alloc kind := false
    if name == "panic" {
        kind := "Generic"
    } elif name == "raise" {
        kind := "Generic"
    } elif name == "_omg_vm_syntax_error_handle" {
        kind := "Syntax"
    } elif name == "_omg_vm_type_error_handle" {
        kind := "Type"
    } elif name == "_omg_vm_undef_ident_error_handle" {
        kind := "UndefinedIdent"
    } elif name == "_omg_vm_value_error_handle" {
        kind := "Value"
    } elif name == "_omg_vm_module_import_error_handle" {
        kind := "ModuleImport"
    }
    if kind == false {
        return false
    }
    if length(args) > 0 {
        compile_expr(args[0])
    } else {
        emit_instr(opcode("PUSH_STR"), "")
    }
    emit_instr(opcode("RAISE"), kind)
    return true
}

# Compile an expression node into bytecode.
proc compile_expr(node) {
    alloc op := node[0]
    if op == "number" {
        emit_instr(opcode("PUSH_INT"), node[1])
    } elif op == "string" {
        emit_instr(opcode("PUSH_STR"), node[1])
    } elif op == "bool" {
        emit_instr(opcode("PUSH_BOOL"), node[1])
    } elif op == "ident" {
        emit_instr(opcode("LOAD"), node[1])
    } elif op == "list" {
        alloc elements := node[1]
        alloc i := 0
        alloc n := length(elements)
        loop i < n {
            compile_expr(elements[i])
            i := i + 1
        }
        emit_instr(opcode("BUILD_LIST"), n)
    } elif op == "dict" {
        alloc pairs := node[1]
        alloc i := 0
        alloc n := length(pairs)
        loop i < n {
            alloc pair := pairs[i]
            compile_expr(pair[0])
            compile_expr(pair[1])
            i := i + 1
        }
        emit_instr(opcode("BUILD_DICT"), n)
    } elif op == "index" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("INDEX"), false)
    } elif op == "slice" {
        compile_expr(node[1])
        compile_expr(node[2])
        alloc end := node[3]
        if end == false {
            emit_instr(opcode("PUSH_NONE"), false)
        } else {
            compile_expr(end)
        }
        emit_instr(opcode("SLICE"), false)
    } elif op == "dot" {
        compile_expr(node[1])
        emit_instr(opcode("ATTR"), node[2])
    } elif op == "func_call" {
        alloc func_node := node[1]
        alloc args := node[2]
        if func_node[0] == "ident" {
            alloc name := func_node[1]
            if compile_raise_call(name, args) == false {
                alloc i := 0
                alloc n := length(args)
                loop i < n {
                    compile_expr(args[i])
                    i := i + 1
                }
                if is_builtin(name) {
                    emit_instr(opcode("BUILTIN"), [name, n])
                } else {
                    emit_instr(opcode("CALL"), name)
                }
            }
        } else {
            compile_expr(func_node)
            alloc i := 0
            alloc n := length(args)
            loop i < n {
                compile_expr(args[i])
                i := i + 1
            }
            emit_instr(opcode("CALL_VALUE"), n)
        }
    } elif op == "unary" {
        alloc unary_op := node[1]
        compile_expr(node[2])
        if unary_op == "sub" {
            emit_instr(opcode("NEG"), false)
        } elif unary_op == "add" {
            # unary plus does not modify the value
            alloc noop := 0
        }
    } elif op == "bitnot" {
        compile_expr(node[1])
        emit_instr(opcode("NOT"), false)
    } elif op == "add" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("ADD"), false)
    } elif op == "sub" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("SUB"), false)
    } elif op == "mul" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("MUL"), false)
    } elif op == "div" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("DIV"), false)
    } elif op == "mod" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("MOD"), false)
    } elif op == "eq" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("EQ"), false)
    } elif op == "ne" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("NE"), false)
    } elif op == "gt" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("GT"), false)
    } elif op == "lt" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("LT"), false)
    } elif op == "ge" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("GE"), false)
    } elif op == "le" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("LE"), false)
    } elif op == "and" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("AND"), false)
    } elif op == "or" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("OR"), false)
    } elif op == "band" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("BAND"), false)
    } elif op == "bor" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("BOR"), false)
    } elif op == "bxor" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("BXOR"), false)
    } elif op == "shl" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("SHL"), false)
    } elif op == "shr" {
        compile_expr(node[1])
        compile_expr(node[2])
        emit_instr(opcode("SHR"), false)
    } else {
        raise("RuntimeError: Unsupported expression node: " + op)
    }
}

# ------------------------------------------------------------------
# Compilation entry points
# ------------------------------------------------------------------

# Compile an AST into final bytecode.
proc compile(ast) {
    code := []
    pending_funcs := []
    funcs := []
    break_stack := []
    compile_block(ast)
    emit_instr(opcode("HALT"), false)
    alloc final_code := code
    alloc i := 0
    loop i < length(pending_funcs) {
        alloc entry := pending_funcs[i]
        alloc name := entry[0]
        alloc params := entry[1]
        alloc body := entry[2]
        alloc addr := length(final_code)
        funcs := funcs + [make_function_entry(name, params, addr)]
        alloc j := 0
        loop j < length(body) {
            alloc ins := body[j]
            alloc op := ins[0]
            alloc arg := ins[1]
            if (op == opcode("JUMP") or op == opcode("JUMP_IF_FALSE")) and arg != false {
                final_code := final_code + [[op, arg + addr]]
            } else {
                final_code := final_code + [[op, arg]]
            }
            j := j + 1
        }
        i := i + 1
    }
    return encode_bytecode(final_code)
}

# Compile source string into bytecode.
proc compile_source(source, file) {
    alloc ast := OMGInterpreter.parse(source)
    return compile(ast)
}

# ------------------------------------------------------------------
# CLI entry point
# ------------------------------------------------------------------

if length(args) > 0 {
    alloc path := args[0]
    alloc src := read_file(path)
    if src == false {
        raise("RuntimeError: Failed to read file: " + path)
    }
    alloc bc := compile_source(src, path)
    if length(args) > 1 {
        alloc out_path := args[1]
        write_file(out_path, bc)
    } else {
        emit bc
    }
}
