# OMG Language Grammar (DHParser dialect)
#
# This grammar describes the syntax of the toy programming language
# implemented in the `omglang` project.  It is written using the
# EBNF dialect accepted by DHParser.  Rules end with a semicolon;
# repetition uses braces `{ ... }`, optional constructs use square
# brackets `[ ... ]`, and negative lookahead is used to match EOF.
#
# The language supports variable declarations (`thingy`), assignments,
# function definitions (`bitchin`), conditionals (`maybe`/`oractually`/`okthen`),
# loops (`roundabout`), output (`saywhat`), assertions (`facts`), and
# returns (`gimme`).  Expressions support comparison, additive and
# multiplicative operators and can include nested function calls.

@whitespace = /[ \t]*/        # skip spaces and tabs
@comment = /#[^\n]*/          # ignore comments during parsing
@literalws = right            # allow whitespace after literals
@drop = whitespace            # drop whitespace tokens from the AST

program = header? statement_list EOF ;

NEWLINE = /([ \t]*#[^\n]*)?\r?\n/ ;
header = ";;;omg" { NEWLINE } ;

# A list of statements separated by newlines.  Leading and trailing
# newlines are ignored.  At least one newline must separate consecutive
# statements.
statement_list = { NEWLINE } [ statement { NEWLINE+ statement } ] { NEWLINE } ;

statement = facts_stmt
          | echo_stmt
          | if_stmt
          | while_stmt
          | func_def
          | assignment_stmt
          | reassignment_stmt
          | func_call_stmt
          | return_stmt
          ;

facts_stmt = "facts" comparison ;
echo_stmt  = "saywhat" "<<" comparison ;

if_stmt = "maybe" comparison block
          { "oractually" comparison block }
          [ "okthen" block ]
          ;

while_stmt = "roundabout" comparison block ;

func_def = "bitchin" IDENTIFIER "(" [ param_list ] ")" block ;

return_stmt = "gimme" comparison ;

assignment_stmt   = "thingy" IDENTIFIER ":=" comparison ;
reassignment_stmt = IDENTIFIER ":=" comparison ;

func_call_stmt = IDENTIFIER "(" [ arg_list ] ")" ;

block = "{" statement_list "}" ;

param_list = IDENTIFIER { "," IDENTIFIER } ;
arg_list   = comparison { "," comparison } ;

comparison = expr { comp_op expr } ;
comp_op    = ">=" | "<=" | "==" | ">" | "<" ;

expr    = term { add_op term } ;
add_op  = "+" | "-" ;

term   = factor { mul_op factor } ;
mul_op = "*" | "/" | "%" ;

factor = NUMBER
       | STRING
       | IDENTIFIER "(" [ arg_list ] ")"
       | IDENTIFIER
       | "(" expr ")"
       ;

# Lexical rules
IDENTIFIER = /[A-Za-z][A-Za-z0-9_]*/ ;
NUMBER     = /\d+/ ;
STRING     = /"[^"\\n]*"/ ;


EOF     = !/./ ;