#!/usr/bin/env python3

# WARNING: CAVEAT UTILITOR
#
#  This file was automatically generated by TatSu.
#
#     https://pypi.python.org/pypi/tatsu/
#
#  Any changes you make to it will be overwritten the next time
#  the file is generated.

# ruff: noqa: C405, COM812, I001, F401, PLR1702, PLC2801, SIM117

import sys
from pathlib import Path

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu
from tatsu.parsing import leftrec, nomemo, isname
from tatsu.infos import ParserConfig
from tatsu.util import re, generic_main


KEYWORDS: set[str] = set()


class Buffer(Buffer):
    def __init__(self, text, /, config: ParserConfig | None = None, **settings):
        config = ParserConfig.new(
            config,
            owner=self,
            whitespace=None,
            nameguard=None,
            ignorecase=False,
            namechars='',
            parseinfo=False,
            comments=None,
            eol_comments=None,
            keywords=KEYWORDS,
            start='start',
        )
        config = config.replace(**settings)

        super().__init__(text, config=config)


class Parser(Parser):
    def __init__(self, /, config: ParserConfig | None = None, **settings):
        config = ParserConfig.new(
            config,
            owner=self,
            whitespace=None,
            nameguard=None,
            ignorecase=False,
            namechars='',
            parseinfo=False,
            comments=None,
            eol_comments=None,
            keywords=KEYWORDS,
            start='start',
        )
        config = config.replace(**settings)

        super().__init__(config=config)

    @tatsumasu()
    def _start_(self):

        def block0():
            self._statement_()
        self._closure(block0)
        self._check_eof()

    @tatsumasu()
    def _statement_(self):
        with self._choice():
            with self._option():
                self._var_decl_()
            with self._option():
                self._cout_stmt_()
            self._error(
                'expecting one of: '
                "'cout' 'var' <cout_stmt> <var_decl>"
            )

    @tatsumasu()
    def _var_decl_(self):
        self._token('var')
        self._IDENT_()
        self.name_last_node('name')
        self._token(':=')
        self._expr_()
        with self._optional():
            self._newline_()
        self._define(['name'], [])

    @tatsumasu()
    def _cout_stmt_(self):
        self._token('cout')
        self._token('<<')
        self._expr_()
        with self._optional():
            self._newline_()

    @tatsumasu()
    @leftrec
    def _expr_(self):
        with self._choice():
            with self._option():
                self._expr_()
                self._token('+')
                self._term_()
            with self._option():
                self._expr_()
                self._token('-')
                self._term_()
            with self._option():
                self._term_()
            self._error(
                'expecting one of: '
                '<expr> <factor> <term>'
            )

    @tatsumasu()
    @leftrec
    def _term_(self):
        with self._choice():
            with self._option():
                self._term_()
                self._token('*')
                self._factor_()
            with self._option():
                self._term_()
                self._token('/')
                self._factor_()
            with self._option():
                self._factor_()
            self._error(
                'expecting one of: '
                "'(' <IDENT> <NUMBER> <STRING> <factor>"
                '<term>'
            )

    @tatsumasu()
    def _factor_(self):
        with self._choice():
            with self._option():
                self._token('(')
                self._expr_()
                self._token(')')
            with self._option():
                self._NUMBER_()
            with self._option():
                self._STRING_()
            with self._option():
                self._IDENT_()
            self._error(
                'expecting one of: '
                '"[^"\\n]*" \'(\' <IDENT> <NUMBER> <STRING>'
                '[A-Za-z_][A-Za-z0-9_]* \\d+'
            )

    @tatsumasu()
    def _newline_(self):
        self._token('\n')

    @tatsumasu()
    def _IDENT_(self):
        self._pattern('[A-Za-z_][A-Za-z0-9_]*')

    @tatsumasu()
    def _NUMBER_(self):
        self._pattern('\\d+')

    @tatsumasu()
    def _STRING_(self):
        self._pattern('"[^"\\n]*"')


def main(filename, **kwargs):
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        text = Path(filename).read_text()
    parser = Parser()
    return parser.parse(
        text,
        filename=filename,
        **kwargs,
    )


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, Parser, name='')
    data = asjson(ast)
    print(json.dumps(data, indent=2))
