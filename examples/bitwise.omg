;;;omg

# Demonstrate bitwise operations

# Bitwise AND: 6 & 3 = 2
io a := 6 & 3

# Bitwise OR: 6 | 3 = 7
io b := 6 | 3

# Bitwise XOR: 6 ^ 3 = 5
io c := 6 ^ 3

# Bitwise NOT: ~6 = -7
io d := ~6

# Bit shift left: 3 << 2 = 12
io e := 3 << 2

# Bit shift right: 8 >> 1 = 4
io f := 8 >> 1

# Output the results
ɀ ¬¬ a  # 2
ɀ ¬¬ b  # 7
ɀ ¬¬ c  # 5
ɀ ¬¬ d  # -7
ɀ ¬¬ e  # 12
ɀ ¬¬ f  # 4

# Flag bitmasks
io FLAG_1 := 0b0001  # 1
io FLAG_2 := 0b0010  # 2
io FLAG_3 := 0b0100  # 4
io FLAG_4 := 0b1000  # 8

# Start with FLAG_1 set
io flags := FLAG_1

ɀ ¬¬ "Initial flags: " + flags

# Set FLAG_3
flags := flags | FLAG_3
ɀ ¬¬ "After setting FLAG_3: " + flags

# Check if FLAG_3 is set
⨇ flags & FLAG_3 != 0 {
    ɀ ¬¬ "FLAG_3 is set"
}

# Check if FLAG_2 is set
⨇ flags & FLAG_2 != 0 {
    ɀ ¬¬ "FLAG_2 is set"
} ∵ {
    ɀ ¬¬ "FLAG_2 is not set"
}

# Toggle FLAG_1 (should unset it)
flags := flags ^ FLAG_1
ɀ ¬¬ "After toggling FLAG_1: " + flags

# Clear FLAG_3 (using bitwise AND with complement)
flags := flags & ~FLAG_3
ɀ ¬¬ "After clearing FLAG_3: " + flags

# Final flag state
ɀ ¬¬ "Final flags: " + flags
