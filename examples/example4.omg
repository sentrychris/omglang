;;;omg

# Euclid's GCD function
bitchin gcd(a, b) {
    maybe b == 0 {
        gimme a
    } okthen {
        gimme gcd(b, a % b)
    }
}

# Factorial function (recursive)
bitchin factorial(n) {
    maybe n <= 1 {
        gimme 1
    } okthen {
        gimme n * factorial(n - 1)
    }
}

# Armstrong (narcissistic) number check for 3-digit numbers
bitchin armstrong(n) {
    thingy sum := 0
    thingy temp := n
    hamsterwheel temp > 0 {
        digit := temp % 10
        sum := sum + digit * digit * digit
        temp := temp / 10
    }
    maybe sum == n {
        gimme 1
    } okthen {
        gimme 0
    }
}

# Collatz step counter
bitchin collatz_steps(n) {
    thingy count := 0
    thingy current := n
    hamsterwheel current > 1 {
        maybe current % 2 == 0 {
            current := current / 2
        } okthen {
            current := 3 * current + 1
        }
        count := count + 1
    }
    gimme count
}

# Linear congruential generator (poor man's RNG)
bitchin lcg(seed) {
    gimme (seed * 1103515245 + 12345) % 32768
}

# Prime check (trial division)
bitchin is_prime(n) {
    maybe n <= 1 {
        gimme 0
    }
    thingy i := 2
    hamsterwheel i * i <= n {
        maybe n % i == 0 {
            gimme 0
        }
        i := i + 1
    }
    gimme 1
}

# Digit sum
bitchin digit_sum(n) {
    thingy sum := 0
    thingy temp := n
    hamsterwheel temp > 0 {
        sum := sum + (temp % 10)
        temp := temp / 10
    }
    gimme sum
}

# Classify number: combine multiple properties into a descriptive string.
bitchin classify(n, prev, seed) {
    thingy primeflag := is_prime(n)
    thingy arm := armstrong(n)
    thingy gcdval := gcd(n, prev)
    thingy coll := collatz_steps(n)
    thingy nextseed := lcg(seed)
    thingy digits := digit_sum(n)
    thingy modval := digits % 5
    thingy fact := factorial(modval)

    maybe primeflag == 1 {
        maybe arm == 1 {
            gimme "Number " + n + " is prime and armstrong, gcd with previous = " + gcdval + ", collatz steps = " + coll + ", rand = " + nextseed + ", fact(" + modval + ") = " + fact
        } okthen {
            gimme "Number " + n + " is prime, gcd with previous = " + gcdval + ", collatz steps = " + coll + ", rand = " + nextseed + ", fact(" + modval + ") = " + fact
        }
    } oractually arm == 1 {
        gimme "Number " + n + " is armstrong, gcd with previous = " + gcdval + ", collatz steps = " + coll + ", rand = " + nextseed + ", fact(" + modval + ") = " + fact
    } okthen {
        gimme "Number " + n + " is composite, gcd with previous = " + gcdval + ", collatz steps = " + coll + ", rand = " + nextseed + ", fact(" + modval + ") = " + fact
    }
}

# Main routine: iterate over a range and classify numbers.
thingy start := 1
thingy stop := 20
thingy prev := 1
thingy seed := 123
thingy current := start

hamsterwheel current <= stop {
    saywhat << classify(current, prev, seed)
    prev := current
    seed := lcg(seed)
    current := current + 1
}

# Validate a few known properties using 'facts'
facts is_prime(97)
facts armstrong(153)

thingy gcd_val:= gcd(48, 18)
facts gcd_val
maybe gcd_val == 6 {
    facts gcd_val
} okthen {
    saywhat << "GCD is incorrect"
}
