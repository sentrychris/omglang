;;;omg
alloc tok_len := 0
proc is_digit(ch) {
    return ch >= "0" and ch <= "9"
}
proc is_alpha(ch) {
    return (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or ch == "_"
}
proc is_alnum(ch) {
    return is_alpha(ch) or is_digit(ch)
}
proc read_number(src, i) {
    alloc num := 0
    alloc c := ""
    loop i < length(src) and is_digit(src[i]) {
        c := src[i]
        num := num * 10 + ascii(c) - ascii("0")
        i := i + 1
    }
    return [num, i]
}
proc read_ident(src, i) {
    alloc s := ""
    loop i < length(src) and is_alnum(src[i]) {
        s := s + src[i]
        i := i + 1
    }
    return [s, i]
}
proc tokenize(src) {
    alloc tokens := {}
    alloc n := 0
    alloc i := 0
    alloc c := ""
    alloc res := []
    alloc word := ""
    alloc s := ""
    if length(src) >= 6 and src[0] == ";" and src[1] == ";" and src[2] == ";" and src[3] == "o" and src[4] == "m" and src[5] == "g" {
        i := 6
        if i < length(src) and src[i] == "\n" {
            i := i + 1
        }
    }
    loop i < length(src) {
        c := src[i]
        if c == " " or c == "\t" {
            i := i + 1
        } elif c == "\n" {
            i := i + 1
        } elif c == "#" {
            loop i < length(src) and src[i] != "\n" {
                i := i + 1
            }
        } elif c == ":" and i + 1 < length(src) and src[i + 1] == "=" {
            tokens[n] := ["symbol", ":="]
            n := n + 1
            i := i + 2
        } elif c == ":" {
            tokens[n] := ["symbol", ":"]
            n := n + 1
            i := i + 1
        } elif c == "=" and i + 1 < length(src) and src[i + 1] == "=" {
            tokens[n] := ["symbol", "=="]
            n := n + 1
            i := i + 2
        } elif c == "!" and i + 1 < length(src) and src[i + 1] == "=" {
            tokens[n] := ["symbol", "!="]
            n := n + 1
            i := i + 2
        } elif c == "<" and i + 1 < length(src) and src[i + 1] == "=" {
            tokens[n] := ["symbol", "<="]
            n := n + 1
            i := i + 2
        } elif c == ">" and i + 1 < length(src) and src[i + 1] == "=" {
            tokens[n] := ["symbol", ">="]
            n := n + 1
            i := i + 2
        } elif c == "(" or c == ")" or c == "{" or c == "}" or c == "," or c == "+" or c == "-" or c == "*" or c == "/" or c == "<" or c == ">" or c == "[" or c == "]" {
            tokens[n] := ["symbol", c]
            n := n + 1
            i := i + 1
        } elif is_digit(c) {
            res := read_number(src, i)
            tokens[n] := ["number", res[0]]
            n := n + 1
            i := res[1]
        } elif c == "\"" {
            i := i + 1
            s := ""
            loop i < length(src) and src[i] != "\"" {
                if src[i] == "\\" and src[i + 1] == "n" {
                    s := s + "\n"
                    i := i + 2
                } else {
                    s := s + src[i]
                    i := i + 1
                }
            }
            i := i + 1
            tokens[n] := ["string", s]
            n := n + 1
        } else {
            res := read_ident(src, i)
            word := res[0]
            i := res[1]
            if word == "alloc" or word == "emit" or word == "proc" or word == "return" or word == "if" or word == "else" or word == "loop" or word == "break" or word == "and" or word == "or" {
                tokens[n] := ["kw", word]
                n := n + 1
            } elif word == "true" {
                tokens[n] := ["bool", true]
                n := n + 1
            } elif word == "false" {
                tokens[n] := ["bool", false]
                n := n + 1
            } else {
                tokens[n] := ["ident", word]
                n := n + 1
            }
        }
    }
    tok_len := n
    return tokens
}
proc parse(source) {
    alloc tokens := tokenize(source)
    alloc res := parse_program(tokens, 0)
    return res[0]
}
proc parse_program(tokens, i) {
    alloc stmts := []
    alloc res := [false, i]
    loop res[1] < tok_len {
        res := parse_statement(tokens, res[1])
        stmts := stmts + [res[0]]
    }
    return [stmts, res[1]]
}
proc parse_statement(tokens, i) {
    alloc t := tokens[i]
    if t[0] == "kw" and t[1] == "alloc" {
        alloc name := tokens[i + 1]
        alloc res := parse_expression(tokens, i + 3)
        return [["decl", name[1], res[0]], res[1]]
    } elif t[0] == "kw" and t[1] == "emit" {
        alloc res := parse_expression(tokens, i + 1)
        return [["emit", res[0]], res[1]]
    } elif t[0] == "kw" and t[1] == "return" {
        alloc res := parse_expression(tokens, i + 1)
        return [["return", res[0]], res[1]]
    } elif t[0] == "kw" and t[1] == "break" {
        return [["break"], i + 1]
    } elif t[0] == "kw" and t[1] == "loop" {
        alloc res_cond := parse_expression(tokens, i + 1)
        alloc res_block := parse_block(tokens, res_cond[1])
        return [["loop", res_cond[0], res_block[0]], res_block[1]]
    } elif t[0] == "kw" and t[1] == "if" {
        alloc res_cond := parse_expression(tokens, i + 1)
        alloc res_then := parse_block(tokens, res_cond[1])
        alloc else_block := []
        alloc j := res_then[1]
        if j < tok_len and tokens[j][0] == "kw" and tokens[j][1] == "else" {
            alloc res_else := parse_block(tokens, j + 1)
            else_block := res_else[0]
            j := res_else[1]
        }
        return [["if", res_cond[0], res_then[0], else_block], j]
    } elif t[0] == "kw" and t[1] == "proc" {
        alloc name := tokens[i + 1][1]
        alloc j := i + 3
        alloc params := []
        if tokens[j][0] != "symbol" or tokens[j][1] != ")" {
            loop true {
                params := params + [tokens[j][1]]
                j := j + 1
                if tokens[j][0] == "symbol" and tokens[j][1] == "," {
                    j := j + 1
                } else {
                    break
                }
            }
        }
        j := j + 1
        alloc res_block := parse_block(tokens, j)
        return [["func_def", name, params, res_block[0]], res_block[1]]
    } else {
        alloc next := tokens[i + 1]
        if next[0] == "symbol" and next[1] == ":=" {
            alloc res := parse_expression(tokens, i + 2)
            return [["assign", t[1], res[0]], res[1]]
        } else {
            alloc res := parse_expression(tokens, i)
            return [res[0], res[1]]
        }
    }
}
proc parse_block(tokens, i) {
    alloc stmts := []
    alloc j := i
    alloc res := [false, 0]
    j := j + 1
    loop tokens[j][0] != "symbol" or tokens[j][1] != "}" {
        res := parse_statement(tokens, j)
        stmts := stmts + [res[0]]
        j := res[1]
    }
    return [stmts, j + 1]
}
proc parse_expression(tokens, i) {
    return parse_or(tokens, i)
}
proc parse_or(tokens, i) {
    alloc res := parse_and(tokens, i)
    alloc left := res[0]
    alloc j := res[1]
    loop j < tok_len and tokens[j][0] == "kw" and tokens[j][1] == "or" {
        alloc right_res := parse_and(tokens, j + 1)
        left := ["or", left, right_res[0]]
        j := right_res[1]
    }
    return [left, j]
}
proc parse_and(tokens, i) {
    alloc res := parse_comparison(tokens, i)
    alloc left := res[0]
    alloc j := res[1]
    loop j < tok_len and tokens[j][0] == "kw" and tokens[j][1] == "and" {
        alloc right_res := parse_comparison(tokens, j + 1)
        left := ["and", left, right_res[0]]
        j := right_res[1]
    }
    return [left, j]
}
proc parse_comparison(tokens, i) {
    alloc res := parse_add_sub(tokens, i)
    alloc left := res[0]
    alloc j := res[1]
    loop j < tok_len and tokens[j][0] == "symbol" and (tokens[j][1] == "<" or tokens[j][1] == "==" or tokens[j][1] == ">" or tokens[j][1] == "<=" or tokens[j][1] == ">=" or tokens[j][1] == "!=") {
        alloc op := tokens[j]
        alloc right_res := parse_add_sub(tokens, j + 1)
        if op[1] == "<" {
            left := ["lt", left, right_res[0]]
        } elif op[1] == ">" {
            left := ["gt", left, right_res[0]]
        } elif op[1] == "<=" {
            left := ["le", left, right_res[0]]
        } elif op[1] == ">=" {
            left := ["ge", left, right_res[0]]
        } elif op[1] == "==" {
            left := ["eq", left, right_res[0]]
        } else {
            left := ["ne", left, right_res[0]]
        }
        j := right_res[1]
    }
    return [left, j]
}
proc parse_add_sub(tokens, i) {
    alloc res := parse_term(tokens, i)
    alloc left := res[0]
    alloc j := res[1]
    loop j < tok_len and tokens[j][0] == "symbol" and (tokens[j][1] == "+" or tokens[j][1] == "-") {
        alloc op := tokens[j]
        alloc right_res := parse_term(tokens, j + 1)
        if op[1] == "+" {
            left := ["add", left, right_res[0]]
        } else {
            left := ["sub", left, right_res[0]]
        }
        j := right_res[1]
    }
    return [left, j]
}
proc parse_term(tokens, i) {
    alloc res := parse_factor(tokens, i)
    alloc left := res[0]
    alloc j := res[1]
    loop j < tok_len and tokens[j][0] == "symbol" and (tokens[j][1] == "*" or tokens[j][1] == "/") {
        alloc op := tokens[j]
        alloc right_res := parse_factor(tokens, j + 1)
        if op[1] == "*" {
            left := ["mul", left, right_res[0]]
        } else {
            left := ["div", left, right_res[0]]
        }
        j := right_res[1]
    }
    return [left, j]
}
proc parse_factor(tokens, i) {
    alloc t := tokens[i]
    alloc node := false
    alloc j := i
    if t[0] == "symbol" and t[1] == "-" {
        alloc res := parse_factor(tokens, i + 1)
        return [["unary", "sub", res[0]], res[1]]
    } elif t[0] == "number" {
        node := ["number", t[1]]
        j := i + 1
    } elif t[0] == "bool" {
        node := ["bool", t[1]]
        j := i + 1
    } elif t[0] == "string" {
        node := ["string", t[1]]
        j := i + 1
    } elif t[0] == "ident" {
        if i + 1 < length(tokens) and tokens[i + 1][0] == "symbol" and tokens[i + 1][1] == "(" {
            alloc k := i + 2
            alloc args := []
            alloc res := [false, 0]
            if tokens[k][0] != "symbol" or tokens[k][1] != ")" {
                loop true {
                    res := parse_expression(tokens, k)
                    args := args + [res[0]]
                    k := res[1]
                    if tokens[k][0] == "symbol" and tokens[k][1] == "," {
                        k := k + 1
                    } else {
                        break
                    }
                }
            }
            node := ["func_call", ["ident", t[1]], args]
            j := k + 1
        } else {
            node := ["ident", t[1]]
            j := i + 1
        }
    } elif t[0] == "symbol" and t[1] == "[" {
        alloc elems := []
        alloc k := i + 1
        alloc res := [false, 0]
        if tokens[k][0] != "symbol" or tokens[k][1] != "]" {
            loop true {
                res := parse_expression(tokens, k)
                elems := elems + [res[0]]
                k := res[1]
                if tokens[k][0] == "symbol" and tokens[k][1] == "," {
                    k := k + 1
                } else {
                    break
                }
            }
        }
        node := ["list", elems]
        j := k + 1
    } elif t[0] == "symbol" and t[1] == "{" {
        alloc pairs := []
        alloc k := i + 1
        alloc key_res := [false, 0]
        alloc val_res := [false, 0]
        if tokens[k][0] != "symbol" or tokens[k][1] != "}" {
            loop true {
                key_res := parse_expression(tokens, k)
                k := key_res[1] + 1
                val_res := parse_expression(tokens, k)
                pairs := pairs + [[key_res[0], val_res[0]]]
                k := val_res[1]
                if tokens[k][0] == "symbol" and tokens[k][1] == "," {
                    k := k + 1
                } else {
                    break
                }
            }
        }
        node := ["dict", pairs]
        j := k + 1
    } elif t[0] == "symbol" and t[1] == "(" {
        alloc res := parse_expression(tokens, i + 1)
        node := res[0]
        j := res[1] + 1
    } else {
        node := ["number", 0]
        j := i + 1
    }
    loop j < tok_len and tokens[j][0] == "symbol" and tokens[j][1] == "[" {
        alloc inner := parse_expression(tokens, j + 1)
        alloc k := inner[1]
        if tokens[k][0] == "symbol" and tokens[k][1] == ":" {
            if tokens[k + 1][0] == "symbol" and tokens[k + 1][1] == "]" {
                node := ["slice", node, inner[0], false]
                j := k + 2
            } else {
                alloc end_res := parse_expression(tokens, k + 1)
                node := ["slice", node, inner[0], end_res[0]]
                j := end_res[1] + 1
            }
        } else {
            node := ["index", node, inner[0]]
            j := k + 1
        }
    }
    return [node, j]
}
alloc global_env := []
proc lookup_var(env, name) {
    alloc i := 0
    alloc entry := false
    loop i < length(env) {
        entry := env[i]
        if entry[0] == name {
            return [true, entry[1]]
        }
        i := i + 1
    }
    i := 0
    entry := false
    loop i < length(global_env) {
        entry := global_env[i]
        if entry[0] == name {
            return [true, entry[1]]
        }
        i := i + 1
    }
    return [false, false]
}
proc env_set(env, name, value) {
    alloc i := 0
    alloc entry := false
    loop i < length(env) {
        entry := env[i]
        if entry[0] == name {
            env[i] := [name, value]
            return env
        }
        i := i + 1
    }
    env := env + [[name, value]]
    return env
}
proc copy_env(env) {
    alloc result := []
    alloc i := 0
    alloc entry := false
    loop i < length(env) {
        entry := env[i]
        result := result + [entry]
        i := i + 1
    }
    return result
}
proc call_function(func, args, env) {
    if func[0] == "function" {
        alloc params := func[1]
        alloc body := func[2]
        alloc captured := func[3]
        alloc local := copy_env(captured)
        alloc i := 0
        loop i < length(params) {
            local := env_set(local, params[i], args[i])
            i := i + 1
        }
        alloc res := []
        res := execute(body, local, false)
        if res[0] == "return" {
            return res[1]
        }
        return false
    } elif func[0] == "builtin" {
        alloc name := func[1]
        if name == "length" {
            return length(args[0])
        } elif name == "read_file" {
            return read_file(args[0])
        }
        emit "Unknown builtin: " + name
        return false
    } else {
        emit "Not a function value"
        return false
    }
}
proc eval_expr(expr, env) {
    alloc kind := expr[0]
    if kind == "number" {
        return expr[1]
    } elif kind == "string" {
        return expr[1]
    } elif kind == "ident" {
        alloc name := expr[1]
        alloc res := lookup_var(env, name)
        if res[0] {
            return res[1]
        }
        emit "Undefined variable: " + name
        return false
    } elif kind == "add" {
        return eval_expr(expr[1], env) + eval_expr(expr[2], env)
    } elif kind == "sub" {
        return eval_expr(expr[1], env) - eval_expr(expr[2], env)
    } elif kind == "mul" {
        return eval_expr(expr[1], env) * eval_expr(expr[2], env)
    } elif kind == "div" {
        return eval_expr(expr[1], env) / eval_expr(expr[2], env)
    } elif kind == "eq" {
        return eval_expr(expr[1], env) == eval_expr(expr[2], env)
    } elif kind == "ne" {
        return eval_expr(expr[1], env) != eval_expr(expr[2], env)
    } elif kind == "lt" {
        return eval_expr(expr[1], env) < eval_expr(expr[2], env)
    } elif kind == "gt" {
        return eval_expr(expr[1], env) > eval_expr(expr[2], env)
    } elif kind == "le" {
        return eval_expr(expr[1], env) <= eval_expr(expr[2], env)
    } elif kind == "ge" {
        return eval_expr(expr[1], env) >= eval_expr(expr[2], env)
    } elif kind == "and" {
        alloc left := eval_expr(expr[1], env)
        if left {
            return eval_expr(expr[2], env)
        }
        return false
    } elif kind == "or" {
        alloc left := eval_expr(expr[1], env)
        if left {
            return left
        }
        return eval_expr(expr[2], env)
    } elif kind == "unary" {
        alloc op := expr[1]
        alloc val := eval_expr(expr[2], env)
        if op == "sub" {
            return 0 - val
        }
        return val
    } elif kind == "list" {
        alloc nodes := expr[1]
        alloc result := []
        alloc i := 0
        loop i < length(nodes) {
            result := result + [eval_expr(nodes[i], env)]
            i := i + 1
        }
        return result
    } elif kind == "dict" {
        alloc pairs := expr[1]
        alloc result := {}
        alloc i := 0
        alloc pair := false
        alloc key := false
        alloc val := false
        loop i < length(pairs) {
            pair := pairs[i]
            key := eval_expr(pair[0], env)
            val := eval_expr(pair[1], env)
            result[key] := val
            i := i + 1
        }
        return result
    } elif kind == "slice" {
        alloc base := eval_expr(expr[1], env)
        alloc start := eval_expr(expr[2], env)
        alloc end_node := expr[3]
        if end_node {
            alloc end := eval_expr(end_node, env)
            return base[start:end]
        }
        return base[start:]
    } elif kind == "index" {
        alloc base := eval_expr(expr[1], env)
        alloc idx := eval_expr(expr[2], env)
        return base[idx]
    } elif kind == "func_call" {
        alloc func_val := eval_expr(expr[1], env)
        alloc arg_nodes := expr[2]
        alloc args := []
        alloc i := 0
        loop i < length(arg_nodes) {
            args := args + [eval_expr(arg_nodes[i], env)]
            i := i + 1
        }
        return call_function(func_val, args, env)
    } else {
        emit "Unknown expr kind: " + kind
        return false
    }
}
proc execute(stmts, env, is_global) {
    alloc i := 0
    alloc stmt := false
    alloc kind := false
    alloc res := ["normal", false]
    loop i < length(stmts) {
        stmt := stmts[i]
        kind := stmt[0]
        if kind == "decl" {
            env := env_set(env, stmt[1], eval_expr(stmt[2], env))
            if is_global { global_env := env }
        } elif kind == "assign" {
            env := env_set(env, stmt[1], eval_expr(stmt[2], env))
            if is_global { global_env := env }
        } elif kind == "emit" {
            emit eval_expr(stmt[1], env)
        } elif kind == "if" {
            alloc cond := eval_expr(stmt[1], env)
            res := ["normal", false]
            if cond {
                res := execute(stmt[2], env, is_global)
            } elif length(stmt) > 3 {
                res := execute(stmt[3], env, is_global)
            }
            if res[0] != "normal" {
                return res
            }
        } elif kind == "loop" {
            alloc loop_res := ["normal", false]
            loop eval_expr(stmt[1], env) {
                loop_res := execute(stmt[2], env, is_global)
                if loop_res[0] == "break" {
                    break
                } elif loop_res[0] == "return" {
                    return loop_res
                }
            }
        } elif kind == "break" {
            return ["break", false]
        } elif kind == "return" {
            alloc val := eval_expr(stmt[1], env)
            return ["return", val]
        } elif kind == "func_def" {
            alloc name := stmt[1]
            alloc params := stmt[2]
            alloc body := stmt[3]
            alloc func_val := ["function", params, body, []]
            env := env_set(env, name, func_val)
            if is_global { global_env := env }
            alloc res_lookup := lookup_var(env, name)
            func_val := res_lookup[1]
            func_val[3] := copy_env(env)
        } elif kind == "func_call" {
            alloc func_val := eval_expr(stmt[1], env)
            alloc arg_nodes := stmt[2]
            alloc args := []
            alloc j := 0
            loop j < length(arg_nodes) {
                args := args + [eval_expr(arg_nodes[j], env)]
                j := j + 1
            }
            _ := call_function(func_val, args, env)
        } else {
            emit "Unknown statement: " + kind
        }
        i := i + 1
    }
    return ["normal", false]
}
proc run(source) {
    alloc ast := parse(source)
    alloc env := [["length", ["builtin", "length"]], ["read_file", ["builtin", "read_file"]], ["ascii", ["builtin", "ascii"]]]
    env := env_set(env, "args", args)
    global_env := env
    return execute(ast, env, true)
}
proc run_file_with_args(path, file_args) {
    alloc saved := args
    args := file_args
    alloc source := read_file(path)
    if length(source) >= 6 and source[0] == ";" and source[1] == ";" and source[2] == ";" and source[3] == "o" and source[4] == "m" and source[5] == "g" {
        alloc j := 6
        if j < length(source) and source[j] == "\n" {
            j := j + 1
        }
        source := source[j:]
    }
    alloc res := run(source)
    args := saved
    return res
}
proc run_file(path) {
    return run_file_with_args(path, args)
}
if length(args) > 0 {
    run_file(args[0])
}
