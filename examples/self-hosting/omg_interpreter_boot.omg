;;;omg
# Minimal OMG interpreter in a low-level subset.
# Bundles tokenizer, parser, and evaluator using only lists for state.

# ---------------- Tokenizer ----------------
proc read_number(src, i) {
    alloc num := 0
    alloc c := ""
    alloc n := length(src)
    loop i < n and src[i] >= "0" and src[i] <= "9" {
        c := src[i]
        num := num * 10 + ascii(c) - ascii("0")
        i := i + 1
    }
    return [num, i]
}

proc read_ident(src, i) {
    alloc s := ""
    alloc n := length(src)
    alloc ch := ""
    loop i < n {
        ch := src[i]
        if (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z") or ch == "_" or (ch >= "0" and ch <= "9") {
            s := s + ch
            i := i + 1
        } else {
            break
        }
    }
    return [s, i]
}

proc tokenize(src) {
    alloc tokens := []
    alloc i := 0
    alloc c := ""
    alloc res := []
    alloc word := ""
    alloc s := ""
    alloc n := length(src)
    loop i < n {
        c := src[i]
        if c == " " or c == "\t" or c == "\n" {
            i := i + 1
        } elif c == "#" or c == ";" {
            loop i < n and src[i] != "\n" {
                i := i + 1
            }
            i := i + 1
        } elif c == ":" and i + 1 < n and src[i + 1] == "=" {
            tokens := tokens + [["symbol", ":="]]
            i := i + 2
        } elif c == "=" and i + 1 < n and src[i + 1] == "=" {
            tokens := tokens + [["symbol", "=="]]
            i := i + 2
        } elif c == "," or c == "(" or c == ")" or c == "{" or c == "}" or c == "[" or c == "]" or c == "+" or c == "-" or c == "*" or c == "/" or c == "<" or c == ">" {
            tokens := tokens + [["symbol", c]]
            i := i + 1
        } elif c == "\"" {
            i := i + 1
            s := ""
            loop src[i] != "\"" {
                if src[i] == "\\" and src[i + 1] == "n" {
                    s := s + "\n"
                    i := i + 2
                } else {
                    s := s + src[i]
                    i := i + 1
                }
            }
            i := i + 1
            tokens := tokens + [["string", s]]
        } elif c >= "0" and c <= "9" {
            res := read_number(src, i)
            tokens := tokens + [["number", res[0]]]
            i := res[1]
        } elif (c >= "a" and c <= "z") or (c >= "A" and c <= "Z") or c == "_" {
            res := read_ident(src, i)
            word := res[0]
            i := res[1]
            if word == "alloc" or word == "proc" or word == "if" or word == "else" or word == "loop" or word == "return" or word == "break" or word == "emit" {
                tokens := tokens + [["kw", word]]
            } elif word == "true" {
                tokens := tokens + [["bool", true]]
            } elif word == "false" {
                tokens := tokens + [["bool", false]]
            } else {
                tokens := tokens + [["ident", word]]
            }
        } else {
            i := i + 1
        }
    }
    return tokens
}

# ---------------- Parser ----------------
proc parse(source) {
    alloc tokens := tokenize(source)
    alloc res := parse_program(tokens, 0)
    return res[0]
}

proc parse_program(tokens, i) {
    alloc stmts := []
    alloc res := [false, i]
    loop res[1] < length(tokens) {
        res := parse_statement(tokens, res[1])
        stmts := stmts + [res[0]]
    }
    return [stmts, res[1]]
}

proc parse_statement(tokens, i) {
    alloc t := tokens[i]
    if t[0] == "kw" and t[1] == "alloc" {
        alloc name := tokens[i + 1]
        alloc res := parse_expression(tokens, i + 3)
        return [["decl", name[1], res[0]], res[1]]
    } elif t[0] == "kw" and t[1] == "emit" {
        alloc res := parse_expression(tokens, i + 1)
        return [["emit", res[0]], res[1]]
    } elif t[0] == "kw" and t[1] == "return" {
        alloc res := parse_expression(tokens, i + 1)
        return [["return", res[0]], res[1]]
    } elif t[0] == "kw" and t[1] == "break" {
        return [["break"], i + 1]
    } elif t[0] == "kw" and t[1] == "loop" {
        alloc res_cond := parse_expression(tokens, i + 1)
        alloc res_block := parse_block(tokens, res_cond[1])
        return [["loop", res_cond[0], res_block[0]], res_block[1]]
    } elif t[0] == "kw" and t[1] == "if" {
        alloc res_cond := parse_expression(tokens, i + 1)
        alloc res_then := parse_block(tokens, res_cond[1])
        alloc else_block := []
        alloc j := res_then[1]
        if j < length(tokens) and tokens[j][0] == "kw" and tokens[j][1] == "else" {
            alloc res_else := parse_block(tokens, j + 1)
            else_block := res_else[0]
            j := res_else[1]
        }
        return [["if", res_cond[0], res_then[0], else_block], j]
    } elif t[0] == "kw" and t[1] == "proc" {
        alloc name := tokens[i + 1][1]
        alloc j := i + 3
        alloc params := []
        if tokens[j][0] != "symbol" or tokens[j][1] != ")" {
            loop true {
                params := params + [tokens[j][1]]
                j := j + 1
                if tokens[j][0] == "symbol" and tokens[j][1] == "," {
                    j := j + 1
                } else {
                    break
                }
            }
        }
        j := j + 1
        alloc res_block := parse_block(tokens, j)
        return [["func_def", name, params, res_block[0]], res_block[1]]
    } else {
        alloc next := tokens[i + 1]
        if next[0] == "symbol" and next[1] == ":=" {
            alloc res := parse_expression(tokens, i + 2)
            return [["assign", t[1], res[0]], res[1]]
        } else {
            alloc res := parse_expression(tokens, i)
            return [res[0], res[1]]
        }
    }
}

proc parse_block(tokens, i) {
    alloc stmts := []
    alloc j := i + 1
    alloc res := [false, 0]
    loop tokens[j][0] != "symbol" or tokens[j][1] != "}" {
        res := parse_statement(tokens, j)
        stmts := stmts + [res[0]]
        j := res[1]
    }
    return [stmts, j + 1]
}

proc parse_expression(tokens, i) {
    return parse_comparison(tokens, i)
}

proc parse_comparison(tokens, i) {
    alloc res := parse_add_sub(tokens, i)
    alloc left := res[0]
    alloc j := res[1]
    alloc op := false
    alloc right_res := [false, 0]
    loop j < length(tokens) and tokens[j][0] == "symbol" and (tokens[j][1] == "<" or tokens[j][1] == "==") {
        op := tokens[j]
        right_res := parse_add_sub(tokens, j + 1)
        if op[1] == "<" {
            left := ["lt", left, right_res[0]]
        } else {
            left := ["eq", left, right_res[0]]
        }
        j := right_res[1]
    }
    return [left, j]
}

proc parse_add_sub(tokens, i) {
    alloc res := parse_term(tokens, i)
    alloc left := res[0]
    alloc j := res[1]
    alloc op := false
    alloc right_res := [false, 0]
    loop j < length(tokens) and tokens[j][0] == "symbol" and (tokens[j][1] == "+" or tokens[j][1] == "-") {
        op := tokens[j]
        right_res := parse_term(tokens, j + 1)
        if op[1] == "+" {
            left := ["add", left, right_res[0]]
        } else {
            left := ["sub", left, right_res[0]]
        }
        j := right_res[1]
    }
    return [left, j]
}

proc parse_term(tokens, i) {
    alloc res := parse_factor(tokens, i)
    alloc left := res[0]
    alloc j := res[1]
    alloc op := false
    alloc right_res := [false, 0]
    loop j < length(tokens) and tokens[j][0] == "symbol" and (tokens[j][1] == "*" or tokens[j][1] == "/") {
        op := tokens[j]
        right_res := parse_factor(tokens, j + 1)
        if op[1] == "*" {
            left := ["mul", left, right_res[0]]
        } else {
            left := ["div", left, right_res[0]]
        }
        j := right_res[1]
    }
    return [left, j]
}

proc parse_factor(tokens, i) {
    alloc t := tokens[i]
    if t[0] == "symbol" and t[1] == "-" {
        alloc res := parse_factor(tokens, i + 1)
        return [["unary", "sub", res[0]], res[1]]
    } elif t[0] == "number" {
        return [["number", t[1]], i + 1]
    } elif t[0] == "bool" {
        return [["bool", t[1]], i + 1]
    } elif t[0] == "string" {
        return [["string", t[1]], i + 1]
    } elif t[0] == "ident" {
        if i + 1 < length(tokens) and tokens[i + 1][0] == "symbol" and tokens[i + 1][1] == "(" {
            alloc j := i + 2
            alloc args := []
            alloc res := [false, 0]
            if tokens[j][0] != "symbol" or tokens[j][1] != ")" {
                loop true {
                    res := parse_expression(tokens, j)
                    args := args + [res[0]]
                    j := res[1]
                    if tokens[j][0] == "symbol" and tokens[j][1] == "," {
                        j := j + 1
                    } else {
                        break
                    }
                }
            }
            return [["func_call", ["ident", t[1]], args], j + 1]
        }
        return [["ident", t[1]], i + 1]
    } elif t[0] == "symbol" and t[1] == "(" {
        alloc res := parse_expression(tokens, i + 1)
        return [res[0], res[1] + 1]
    }
    return [["number", 0], i + 1]
}

# ---------------- Interpreter ----------------
alloc global_env := []

proc lookup_var(env, name) {
    alloc i := 0
    alloc entry := false
    loop i < length(env) {
        entry := env[i]
        if entry[0] == name {
            return [true, entry[1]]
        }
        i := i + 1
    }
    i := 0
    loop i < length(global_env) {
        entry := global_env[i]
        if entry[0] == name {
            return [true, entry[1]]
        }
        i := i + 1
    }
    return [false, false]
}

proc env_set(env, name, value) {
    alloc i := 0
    alloc entry := false
    loop i < length(env) {
        entry := env[i]
        if entry[0] == name {
            env[i] := [name, value]
            return env
        }
        i := i + 1
    }
    return env + [[name, value]]
}

proc copy_env(env) {
    alloc i := 0
    alloc res := []
    loop i < length(env) {
        res := res + [env[i]]
        i := i + 1
    }
    return res
}

proc call_function(func, args, env) {
    if func[0] == "function" {
        alloc params := func[1]
        alloc body := func[2]
        alloc captured := func[3]
        alloc local := copy_env(captured)
        alloc i := 0
        loop i < length(params) {
            local := env_set(local, params[i], args[i])
            i := i + 1
        }
        alloc res := execute(body, local, false)
        if res[0] == "return" {
            return res[1]
        }
        return false
    } elif func[0] == "builtin" {
        alloc name := func[1]
        if name == "length" {
            return length(args[0])
        } elif name == "read_file" {
            return read_file(args[0])
        } elif name == "ascii" {
            return ascii(args[0])
        } elif name == "emit" {
            emit args[0]
            return false
        }
        emit "Unknown builtin: " + name
        return false
    }
    emit "Not a function value"
    return false
}

proc eval_expr(expr, env) {
    alloc kind := expr[0]
    if kind == "number" {
        return expr[1]
    } elif kind == "string" {
        return expr[1]
    } elif kind == "bool" {
        return expr[1]
    } elif kind == "ident" {
        alloc res := lookup_var(env, expr[1])
        if res[0] { return res[1] }
        emit "Undefined variable: " + expr[1]
        return false
    } elif kind == "add" {
        return eval_expr(expr[1], env) + eval_expr(expr[2], env)
    } elif kind == "sub" {
        return eval_expr(expr[1], env) - eval_expr(expr[2], env)
    } elif kind == "mul" {
        return eval_expr(expr[1], env) * eval_expr(expr[2], env)
    } elif kind == "div" {
        return eval_expr(expr[1], env) / eval_expr(expr[2], env)
    } elif kind == "lt" {
        return eval_expr(expr[1], env) < eval_expr(expr[2], env)
    } elif kind == "eq" {
        return eval_expr(expr[1], env) == eval_expr(expr[2], env)
    } elif kind == "unary" {
        alloc op := expr[1]
        alloc val := eval_expr(expr[2], env)
        if op == "sub" { return 0 - val }
        return val
    } elif kind == "func_call" {
        alloc func_val := eval_expr(expr[1], env)
        alloc arg_nodes := expr[2]
        alloc args := []
        alloc i := 0
        loop i < length(arg_nodes) {
            args := args + [eval_expr(arg_nodes[i], env)]
            i := i + 1
        }
        return call_function(func_val, args, env)
    }
    emit "Unknown expr kind: " + kind
    return false
}

proc execute(stmts, env, is_global) {
    alloc i := 0
    alloc stmt := false
    alloc kind := ""
    alloc res := ["normal", false]
    alloc cond := false
    alloc loop_res := ["normal", false]
    alloc val := false
    alloc name := ""
    alloc params := []
    alloc body := []
    alloc func_val := false
    alloc res_lookup := false
    alloc arg_nodes := []
    alloc args := []
    alloc j := 0
    loop i < length(stmts) {
        stmt := stmts[i]
        kind := stmt[0]
        if kind == "decl" {
            env := env_set(env, stmt[1], eval_expr(stmt[2], env))
            if is_global { global_env := env }
        } elif kind == "assign" {
            env := env_set(env, stmt[1], eval_expr(stmt[2], env))
            if is_global { global_env := env }
        } elif kind == "emit" {
            emit eval_expr(stmt[1], env)
        } elif kind == "if" {
            cond := eval_expr(stmt[1], env)
            res := ["normal", false]
            if cond {
                res := execute(stmt[2], env, is_global)
            } elif length(stmt) > 3 {
                res := execute(stmt[3], env, is_global)
            }
            if res[0] != "normal" {
                return res
            }
        } elif kind == "loop" {
            loop_res := ["normal", false]
            loop eval_expr(stmt[1], env) {
                loop_res := execute(stmt[2], env, is_global)
                if loop_res[0] == "break" {
                    break
                } elif loop_res[0] == "return" {
                    return loop_res
                }
            }
        } elif kind == "break" {
            return ["break", false]
        } elif kind == "return" {
            val := eval_expr(stmt[1], env)
            return ["return", val]
        } elif kind == "func_def" {
            name := stmt[1]
            params := stmt[2]
            body := stmt[3]
            func_val := ["function", params, body, []]
            env := env_set(env, name, func_val)
            if is_global { global_env := env }
            res_lookup := lookup_var(env, name)
            func_val := res_lookup[1]
            func_val[3] := copy_env(env)
        } elif kind == "func_call" {
            func_val := eval_expr(stmt[1], env)
            arg_nodes := stmt[2]
            args := []
            j := 0
            loop j < length(arg_nodes) {
                args := args + [eval_expr(arg_nodes[j], env)]
                j := j + 1
            }
            _ := call_function(func_val, args, env)
        }
        i := i + 1
    }
    return ["normal", false]
}

proc run_with_args(source, args) {
    alloc ast := parse(source)
    alloc env := [
        ["length", ["builtin", "length"]],
        ["read_file", ["builtin", "read_file"]],
        ["ascii", ["builtin", "ascii"]],
        ["emit", ["builtin", "emit"]],
        ["args", args]
    ]
    global_env := env
    execute(ast, env, true)
}

proc run(source) {
    run_with_args(source, [])
}

proc run_file_with_args(path, args) {
    alloc src := read_file(path)
    run_with_args(src, args)
}

proc run_file(path) {
    run_file_with_args(path, args)
}

if length(args) > 0 {
    run_file(args[0])
}
